HECHO:
- Makefile con la M en mayúscula

- Gestión de comillas OK. convierte lo que este entre comillas en un solo token
	echo "cat makefile | cat > makefile"
	OK: shell->cmds = 
	[
			[
					Token[0]: 'echo'
					Token[1]: '"cat makefile | cat > makefile"'
			]
	];

	export A="hola B=asdasda"
	OK: shell->cmds = 
	[
		[
				Token[0]: 'export'
				Token[1]: 'A="hola B=asdasda"'
		]
	];

- Sustituido execvp (prohibido) por execve

- Nuevo formato de shell->env, con un array y no una lista enlazada, para cumplir con lo que pide execve

- Expansión de variables OK
	expande variables aun con comillas simples --> CORREGIDO
	echo "cat makefile | cat > makefile" -> crash --> CORREGIDO
	echo 'cat makefile | cat > makefile' -> crash --> CORREGIDO

	export A=1 B=1

	echo $A $B  ---> debe imprimir 1 1
	echo "$A $B"  ---> debe imprimir 1 1
	echo '$A $B'  ---> debe imprimir $A $B

	expr $A + $B  ---> debe dar 2
	expr "$A" + "$B"  ---> debe dar 2
	expr '$A' + '$B'  ---> debe dar error expr: non-integer argument

	export $A=hola ---> debe dar error export: not an identifier: 1
	unset $A ---> debe dar error unset: not an identifier: 1

	unset A
	export A=hola
	export kk=$A
	echo $kk ---> debe imprimir hola

	export A=ls
	$A -l  ---> debería listar directorio



PENDIENTE:
NOTA: eval de arror pq no reconoce el comando. Chatgpt dice que es normal pq es un builtin del shell y no un comando externo
Y que como no nos piden que lo implementemos pues que es normal que no funcione. CHECAR????
export CMD="echo hola"
$CMD  ---> command not found: echo hola
eval $CMD ---> debe imprimir hola
echo "$CMD" ---> debe imprimir echo hola


echo -nnnn hhola -> -nnnn hhola



no esta implementado el builtin exit
exit tiene q matar al hijo o proceso en el quue este.
si haces exit 11 al salir al salir tiene que mostrar $interrogacion = 11





cat + ctrl C -> muestra 2 prompts






mkdir -p a/b/c/d
/tmp/pepese > cd a/b/c/d/
Changed directory to /tmp/pepese/a/b/c/d
/tmp/pepese/a/b/c/d > rm -rf ../../../../

!!SALE de minishell al intentar hacer getcwd en una carpeta que no existe -> deberiamos crear una especie de built in para que no llamar getcwd en cada iteraccion

env > salida

unset PATH -> ls -> sigue funcionando?



redirecion de entrada no funciona
here_doc hace cosas raras

estan esperando a cada hijo en vez de esperar al final a todos

quitar el printf de "changed directory"




usar flags -g3 fsantizer=address

las variables de entorno en llos pipes deben ser también las nuestras )ahora mismo coge las env globales

si hacemos unset de path ls no debería funcionar



Revisa la parte de las redirrecciones ya que si tiene varias se hace mal (BRIAN)




// lo que cambio Brian
// lo que cambio Brian
// lo que cambio Brian
// lo que cambio Brian
// lo que cambio Brian
// lo que cambio Brian
// lo que cambio Brian
// lo que cambio Brian








HECHO:
- Makefile con la M en mayúscula

- Gestión de comillas OK. convierte lo que este entre comillas en un solo token
	echo "cat makefile | cat > makefile"
	OK: shell->cmds = 
	[
			[
					Token[0]: 'echo'
					Token[1]: '"cat makefile | cat > makefile"'
			]
	];

	export A="hola B=asdasda"
	OK: shell->cmds = 
	[
		[
				Token[0]: 'export'
				Token[1]: 'A="hola B=asdasda"'
		]
	];

- Sustituido execvp (prohibido) por execve
- Nuevo formato de shell->env, con un array y no una lista enlazada, para cumplir con lo que pide execve

quitar el printf de "changed directory"

# creo que ya esta esto
mkdir -p a/b/c/d
/tmp/pepese > cd a/b/c/d/
Changed directory to /tmp/pepese/a/b/c/d
/tmp/pepese/a/b/c/d > rm -rf ../../../../
!!SALE de minishell al intentar hacer getcwd en una carpeta que no existe -> deberiamos crear una especie de built in para que no llamar getcwd en cada iteraccion

A CORREGIR:

Esto da un memory leak:
echo hola | grep h

desde que he cambiado a execve parece que no funciona bien el execute. En debug muestra bien los tokens, pero
al ejecutarlos para todo dice: "No such file or directory"

PENDIENTE:

export A=1 B=1
expr $A + $B  ---> debe dar 2
expr "$A" + "$B"  ---> debe dar 2
expr '$A' + '$B'  ---> debe dar error expr: non-integer argument

solo expande variables en el echo
	export $A=hola
	export kk=$A
	echo $kk ---> debe imprimir hola



echo -nnnn hhola -> -nnnn hhola

no esta implementado el builtin exit
exit tiene q matar al hijo o proceso en el que este.
si haces exit 11 al salir al salir tiene que mostrar $interrogacion = 11

cat + ctrl C -> muestra 2 prompts

echo "cat makefile | cat > makefile" -> crash
echo 'cat makefile | cat > makefile' -> crash

expande variables aun con comillas simples

env > salida

unset PATH -> ls -> sigue funcionando?

usar flags -g3 fsantizer=address

si hacemos unset de path ls no debería funcionar

Revisa la parte de las redirrecciones ya que si tiene varias se hace mal (BRIAN)
redirecion de entrada no funciona
here_doc hace cosas raras

estan esperando a cada hijo en vez de esperar al final a todos

las variables de entorno en los pipes deben ser también las nuestras )ahora mismo coge las env globales
