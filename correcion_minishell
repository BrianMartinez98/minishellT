HECHO:
- Makefile con la M en mayúscula

- Gestión de comillas OK. convierte lo que este entre comillas en un solo token
	echo "cat makefile | cat > makefile"
	OK: shell->cmds = 
	[
			[
					Token[0]: 'echo'
					Token[1]: '"cat makefile | cat > makefile"'
			]
	];

	export A="hola B=asdasda"
	OK: shell->cmds = 
	[
		[
				Token[0]: 'export'
				Token[1]: 'A="hola B=asdasda"'
		]
	];


A MEDIO HACER:
- Sustituido execvp (prohibido) por execve --> da error de formato pq execve espera otro formato diferente que nuestra lista enlazada que tenemos en shell->env


export A=1 B=1
expr $A + $B  ---> debe dar 2
expr "$A" + "$B"  ---> debe dar 2
expr '$A' + '$B'  ---> debe dar error expr: non-integer argument

solo expande variables en el echo
	export $A=hola
	export kk=$A
	echo $kk ---> debe imprimir hola


PENDIENTE:

echo -nnnn hhola -> -nnnn hhola

no esta implementado el builtin exit
exit tiene q matar al hijo o proceso en el quue este.
si haces exit 11 al salir al salir tiene que mostrar $interrogacion = 11





cat + ctrl C -> muestra 2 prompts

echo "cat makefile | cat > makefile" -> crash
echo 'cat makefile | cat > makefile' -> crash

expande variables aun con comillas simples


mkdir -p a/b/c/d
/tmp/pepese > cd a/b/c/d/
Changed directory to /tmp/pepese/a/b/c/d
/tmp/pepese/a/b/c/d > rm -rf ../../../../

!!SALE de minishell al intentar hacer getcwd en una carpeta que no existe

env > salida

unset PATH -> ls -> sigue funcionando?



redirecion de entrada no funciona
here_doc hace cosas raras

estan esperando a cada hijo en vez de esperar al final a todos

quitar el printf de "changed directory"




usar flags -g3 fsantizer=address

las variables de entorno en llos pipes deben ser también las nuestras )ahora mismo coge las env globales

si hacemos unset de path ls no debería funcionar


